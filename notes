# Features
## Constraints
- Not use more than one global variable
- Not interpret unclosed quotes or special characters which are not required by the subject such as \ or ;

## TODO
- WOW, Space thing => some things are written in stderr but there are not errors like prompt, "exit" at the end of program, etc
- Delete all comments formated by /* NEED TO BE DELETED */
- Search and launch the right exeutable (PATH + relative/absolute path)
- Handle ' which should prevent the shell from interpreting the metacharacters in the quoted sequence.
- Handle " which should prevent the shell from interpreting the metacharacters in the quoted sequence except for $.
- Implement redirections (< > << >>)
	+ >>
		- Should not update the history
			=> Just one multiline history entry per instruction, not more
- Implement pipes
- Handle $?
- Handle ctrl-C, ctrl-D and ctrl-\ which should behave like in bash
- Implement builtins
	+ Descriptions need to be checked, maybe some errors in there
	+ Making all builtins work like normal commands ?
		=> int	builtin_name(int ac, char **av, char ***env);
	+ export [name[=word]...]
		=> export under linux add variable in a binary tree. Let's not implement that haha
		=> The supplied names are marked for automatic export to the environment of subsequently executed commands.
		=> If no args, print all exported variables (declare -x declare variable with export) (In exported order and with " and co)
			=> $> export
			=> declare -x OLDPWD
			=> declare -x PWD="/mnt/nfs/homes/jmaia/cursus/minishell"
			=> declare -x SHLVL="1"
		=> If name followed by =, it seems logic to me to what happens
		=> Returns 0 except if a name is not a valid shell variable name
			=> bash: export: `2coucou=a': not a valid identifier
			=> Format of name
				- Only lowercase, uppercase, digits and _
					=> $> export 'cou=coucava'=b
					=> $> export
					=> ...
					=> declare -x cou="coucava=b"
				- Do not begin with a digit
	+ env
		=> Print all exported variables in this format in sorted order:
		=> $> env
		=> PWD=/mnt/nfs/homes/jmaia/cursus/minishell
		=> SHLVL=1
		=> _=/usr/bin/env
		
- Implement && and ||
- Implement * for the current working directory

## DONE
- Display a prompt when waiting for a new command
- Have a working history
- In interactive mode => Handle ctrl-C, ctrl-D, ctrl-\
- Implement builtins
	+ cd [dir]
		=> Change the current directory to dir.
		=> If CDDIR is set, search directory in provided directory separated by :
			=> Print now pwd if CDDIR used
		=> Otherwise, search in .
		=> If dir not provided, use $HOME
			=> If home not set, then error:
			=> minshell: cd: HOME not set
		=> Just need to call: int	chdir(const char *path);
		=> Returns 0 if success, 1 if directory change not possible
	+ echo [-n] [arg...]
		=> Print args separated by spaces
		=> Put a newline at the end except when -n provided
		=> echo with an other letter than n, do not take it as option
			=> $> echo -a coucou
			=> -a coucou
		=> Returns 0 if success, 1 if write error occurs
	+ pwd
		=> Print current working directory
		=> If extra args provided => osef
		=> To get current working directory, use:
			=> char *getcwd(char *buf, size_t size);
			=> With getcwd(0, 0), we get the working directory allocated with malloc to the right size (cf. man)
	+ exit [n]
		=> Exit the shell with the exit status n or the last command executed if n not provided
		=> 0 <= n <= 255. If greeter or lower, go modulo
		=> Too many arguments = return_code of 1 and "bash: exit: too many arguments\n"
	+ unset [name...]
		=> For each name, remove the corresponding variable.
		=> Hmm, we do not have to handle basic variable, just env variable. So let's just remove variables from env
		=> Hmm, unset without variable do not do anything

---------------------------------------

utiliser minishell de facon recursive pour gerer les parenthese et les pipes(voir subshell)
https://stackoverflow.com/questions/1312922/detect-if-stdin-is-a-terminal-or-pipe
D'abord on check les builtin et ensuite les commandes

On aurait une struct comme ca
{
	type	operator;
	char	*pipeline;
}	ops;

Pour l'avoir on split sur && et ||, en faisant gaffe a pas être dans une parenthèse\guillemet\etc

Du coup, on aurait une liste de ops, qu'on viendrait traiter une par une
La premìere ops a pour operator = NULL

Ca nous donne un truc comme ca

int	exit_status;

// ICI ON VIENT CHOPPER NOS OPS

while (op)
{
	Si (operator NULL ou ((operator  == 'ET') == (exit_status == 0))) 
		exit_status = exec_pipeline(pipeline)
	op = op->next;
}

//exec_pipeline
On aurait une liste de commandes séparés par des pipes
On execute tout en même temps


-------

Au tout début, on vient copier la variable externe environ dans une liste/tableau un truc comme ça
et c'est ça qu'on passera a execve
